<!doctype html> 
<html prefix="og: http://ogp.me/ns#" lang="en"> 
<head>
    <title>Braid MIDI sequencer</title> 
    <meta charset="utf-8"/>
    <meta name="robots" content="index,follow">
    <meta name="author" content="Brian House" /> 
    <meta name="copyright" content="Brian House" /> 
    <meta name="description" content="
Braid is a single-import module for Python 3 that comprises a musical notation system, livecoding framework, and sequencer for monophonic MIDI synths. Its emphasis is on polyrhythms, phasing, and entrainment." />
    <meta property="og:title" content="Braid" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="http://brianhouse.net/about/about.jpg" />
    <link rel="icon" href="/favicon.png" /> 
    <link rel="stylesheet" type="text/css" href="github-markdown.css" /> <!-- https://github.com/sindresorhus/github-markdown-css -->
    <style>
        body {
            margin: 0px;
            padding: 0px;       
            background: #87e0fd;
            background: linear-gradient(to bottom, #87e0fd 0%,#53cbf1 40%,#05abe0 100%);
        }
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 800px;
            margin: 0;
            margin-left: auto;
            margin-right: auto;
            margin-top: 50px;
            padding: 45px;
            background-color: white;
            border: 1px solid #ccc;
        }
        .int {
            color: #ccc;
        }
        .output {
            color: #ccc;
        }
    </style>    
</head>
<body>
<div id="content" class="markdown-body">

<h1>BRAID</h1>
<p>Braid is a way to make music with code. It comprises a musical notation system, livecoding framework, and sequencer for monophonic MIDI synths. Its emphasis is on polyrhythms, phasing, and entrainment, and it is a single-import module in python.</p>
<ol>
<li><a href="#goals">Goals</a></li>
<li><a href="#reference">Reference</a></li>
<li><a href="#documentation">Documentation</a><ol>
<li><a href="#basic">Basic</a></li>
<li><a href="#notes">Notes and Chords</a></li>
<li><a href="#patterns_1">Patterns 1</a></li>
<li><a href="#patterns_2">Patterns 2</a></li>
</ol>
</li>
</ol>
<h2>Goals</h2>
<ul>
<li>
<p><strong>Idiosyncratic</strong><br />
Braid is not for everyone. It's for me, and is an attempt to embody the methods and aesthetics I've used in my projects&mdash;it's also for anyone else who is interested in thinking similarly. But it is far from general purpose music making. It is also an exercise in developing a langauge. </p>
</li>
<li>
<p><strong>Limited scope</strong><br />
Braid is MIDI-based, and it's monophonic. Those are pretty significant limitations, but it means that this exists and (mostly) works. It also means I can take advantage of all the awesome cheap MIDI monosynths coming out, like the <a href="https://meeblip.com/">Meeblip</a> and the <a href="http://i.korg.com/volcaseries">Korg Volca</a> series.</p>
</li>
<li>
<p><strong>Integrates with Python</strong><br />
I find specialized development environments frustrating, as they limit what's possible to their own sandbox. Braid is just a python module, and as such can be used within other python projects.  </p>
</li>
<li>
<p><strong>Both livecoding and scripting</strong><br />
 Sometimes I want to improvise within a livecoding framework, sometimes I want to make a composition. Braid doesn't make much of a distinction between these ways of operating, as it's all python and uses the interpreter as a livecoding environment. Premade scripts can be easily executed within the interpreter.</p>
</li>
<li>
<p><strong>Works on small devices</strong><br />
Braid is has very low processor overhead, suitable for running on devices like the Raspberry Pi.</p>
</li>
</ul>
<h4>A note on names</h4>
<p>This framework is called Braid, and the fundamental objects are called <em>threads</em>&mdash;a thread corresponds to a hardware or software monosynth, and refers to the temporal operations of Braid through which threads can come in and out of sync. This is not a thread in the programming sense (in that respect Braid is single-threaded).</p>
<h2><a name="documentation"></a>Reference</h2>
<h3>Global functions</h3>
<ul>
<li><code>log_midi(True|False)</code>        Choose whether to see MIDI output (default: False)</li>
<li><code>midi_out_interface(int)</code>     Change MIDI interface for output (zero-indexed)</li>
<li><code>Thread(int channel)</code>         Create a Thread on the specified MIDI channel</li>
<li><code>Scale([ints])</code>               Create a Scale with a list of ints corresponding to half-steps from root (0)</li>
<li><code>play()</code></li>
<li><code>pause()</code></li>
<li><code>stop()</code></li>
<li><code>clear()</code></li>
</ul>
<h3>Symbols</h3>
<ul>
<li><code>K</code>, <code>S</code>, <code>H</code>, <code>O</code></li>
</ul>
<h3>Scales</h3>
<p><code>CHR</code> Chromatic<br />
<code>MAJ</code> Major<br />
<code>DOM</code> Dominant<br />
<code>MIN</code> Harmonic minor<br />
<code>PEN</code> Pentatonic<br />
<code>SUSb9</code> Suspended flat 9<br />
<code>ION</code> Ionian<br />
<code>DOR</code> Dorian<br />
<code>PRG</code> Phrygian<br />
<code>MYX</code> Myxolydian<br />
<code>AOL</code> Aolian<br />
<code>LOC</code> Locrian<br />
<code>MMI</code> ??<br />
<code>BLU</code> Blues<br />
<code>SDR</code> Gamelan Slendro<br />
<code>PLG</code> Gamelan Pelog<br />
<code>JAM</code> jamz  </p>
<h2><a name="documentation"></a>Documentation</h2>
<h3><a name="basic"></a>Basic</h3>
<p>To begin working with Braid, download the repository and navigate to the root directory. Launch a python3 interpreter and import braid: </p>
<pre><code>$ python3
<span class="output">Python 3.6.0 (default, Mar  4 2017, 12:32:37) 
[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwin
Type "help", "copyright", "credits" or "license" for more information.</span>
<span class="int">&gt;&gt;&gt;</span> from braid import *
<span class="output">MIDI outputs available: ['to Max 1', 'to Max 2']
MIDI OUT: to Max 1
MIDI  IN: from Max 1
Loaded VolcaKick
Loaded VolcaBeats
Braid started
Playing</span>
</code></pre>
<p>Now, create a thread&mdash;the fundamental object of Braid&mdash;and start it:</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t = Thread(1)               # create a thread&amp;mdash;the argument indicates the MIDI channel
<span class="int">&gt;&gt;&gt;</span> t.pattern = C, C, C, C      # add a pattern
<span class="int">&gt;&gt;&gt;</span> t.start()                   # start it
</code></pre>
<p>That's it! You should be hearing the steady pulse of progress.</p>
<p>Alternately, you can create a python file with Braid syntax like this:</p>
<pre><code>#!/usr/bin/env python3

from braid import *
t = Thread(1)
t.pattern = C, C, C, C
t.start()

play()
</code></pre>
<p>Save it as <code>hello_world.py</code> and run <code>python3 hello_world.py 0</code>. The (optional) argument is the MIDI out interface to use.  </p>
<p>From now on, we'll assume that we're livecoding within the python3 interpreter, but any code works the same in a standalone file.  </p>
<h3><a name="top"></a>Top-level controls</h3>
<p>You can start and stop individual threads, with <code>my_thread.start()</code> and <code>my_thread.stop()</code>, which essentially behave like a mute button.  </p>
<p>Braid also has some universal playback controls. When Braid launches, it is automatically in play mode. Use <code>pause()</code> to mute everything, and <code>play()</code> to get it going again. If you use <code>stop()</code>, it will stop all threads, so you'll need to start them up again individually. <code>clear()</code> just stops the threads, but Braid itself is still going and if you start a thread it will sound right away.</p>
<p><em>Advanced note</em><br />
If you're doing a lot of livecoding, it's easy to create a new thread with the same name as an old one, and this can lead to orphan threads that you hear but can't reference. Use <code>stop()</code> or <code>clear()</code> to silence these.</p>
<p>Try it now:</p>
<pre><code>clear()
</code></pre>
<h3><a name="notes"></a>Notes and Chords</h3>
<p>Start a thread</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t = Thread(1)   # create a thread on channel 1
<span class="int">&gt;&gt;&gt;</span> t.start()
</code></pre>
<p>MIDI pitch value can be specified by MIDI number or with note-name aliases between C0 and B8. C is an alias for C4, likewise for the rest of the middle octave</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = C, C, C, C
</code></pre>
<p>is the same as  </p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 60, 60, 60, 60
</code></pre>
<p>0s simply sustain (no MIDI sent)  </p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = C, 0, C, C
</code></pre>
<p>Rests (explicit MIDI note-offs) are specified with a Z  </p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = C, Z, C, Z
</code></pre>
<p>By default, there is no specified chord. But if there is one, notes can be specified by scale degree</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.chord = C4, MAJ
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 3, 5, 7
</code></pre>
<p>Negative numbers designate the octave below  </p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = -5, -7, 1, 5
</code></pre>
<p>A chord consists of a root note and a scale. For example, <code>C, MAJ</code> is a major scale built off of C4. That means <code>1, 2, 3, 4, 5</code> is the equivalent of <code>C4, D4, E4, F4, G4</code>. But behind the scenes, it's specified like this: <code>Scale([0, 2, 4, 5, 7, 9, 11])</code>  </p>
<p>Built-in scales are:<br />
<code>CHR</code> Chromatic<br />
<code>MAJ</code> Major<br />
<code>DOM</code> Dominant<br />
<code>MIN</code> Harmonic minor<br />
<code>PEN</code> Pentatonic<br />
<code>SUSb9</code> Suspended flat 9<br />
<code>ION</code> Ionian<br />
<code>DOR</code> Dorian<br />
<code>PRG</code> Phrygian<br />
<code>MYX</code> Myxolydian<br />
<code>AOL</code> Aolian<br />
<code>LOC</code> Locrian<br />
<code>MMI</code> ??<br />
<code>BLU</code> Blues<br />
<code>SDR</code> Gamelan Slendro<br />
<code>PLG</code> Gamelan Pelog<br />
<code>JAM</code> jamz  </p>
<p>Custom scales can be generated with the following syntax, where numbers are chromatic steps from the root</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> whole_tone_scale = Scale([0, 2, 4, 6, 8, 10])
</code></pre>
<p>R specifies a random note in the scale</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.chord = C4, whole_tone_scale
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, R, R, -6
</code></pre>
<p>Grace notes are specified by using floats</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 1., 1., 1.
</code></pre>
<p>Use the g function to create a grace note on note specified with a symbol</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.chord = None
<span class="int">&gt;&gt;&gt;</span> t.pattern = C, g(C), g(C), g(C)
</code></pre>
<h3><a name="patterns_1"></a>Patterns, part 1</h3>
<p>(If you're following along in the documentation, now is a good time to use <code>stop()</code> to clear things out.)</p>
<p>Start a thread</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> clear()
<span class="int">&gt;&gt;&gt;</span> t = Thread(1)
<span class="int">&gt;&gt;&gt;</span> t.chord = C, DOR
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 1, 1, 1
<span class="int">&gt;&gt;&gt;</span> t.start()
</code></pre>
<p>Once started, a thread repeats its pattern. Each repetition is called a <em>cycle</em>. Each cycle is subdivided evenly by the steps in the pattern.</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 0, 1, 0              # 4/4
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 0, 1                 # 3/4
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 1, 0, 1, 1, 0, 1     # 7/8
</code></pre>
<p>Each step of a pattern can be a note, but it can also be a subdivision</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 1, [1, 1], 1, 1
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, [1, 1], 1, [1, 1, 1]
</code></pre>
<p>...or a subdivision of subdivisions, ad finitum</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 1, [2, [1., 1.]], [3, [2, 1], 1.], [5, [4., 3.]]
</code></pre>
<p>So brackets indicate subdivisions. Parens, however, indicate a choice.</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 1, (2, 3, 4), 1, 1
</code></pre>
<p>Brackets and parens can be combined to create intricate markov chains</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> clear()
<span class="int">&gt;&gt;&gt;</span> d = Thread(10)              # channel 10 is MIDI for drums
<span class="int">&gt;&gt;&gt;</span> tempo(132)      
<span class="int">&gt;&gt;&gt;</span>
<span class="int">&gt;&gt;&gt;</span> d.pattern = [([K, H], [K, K]), (K, O)], (H, [H, K]), (S, [S, (O, K), 0, g(S)]), [[H, H], ([H, H], O, [g(S), g(S), g(S), g(S)])]         # K, S, H, O are built-in aliases for 36, 38, 42, 46
<span class="int">&gt;&gt;&gt;</span> d.start()
</code></pre>
<p>Patterns are python lists, so they can be manipulated as such</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern = [K, [O, H]] * 4
<span class="int">&gt;&gt;&gt;</span> d.pattern[2] = S
<span class="int">&gt;&gt;&gt;</span> d.pattern[6] = S
<span class="int">&gt;&gt;&gt;</span> d.pattern[6] = [(S, [S, K])]
</code></pre>
<h3><a name="patterns_2"></a>Patterns, part 2</h3>
<pre><code><span class="int">&gt;&gt;&gt;</span> clear()
<span class="int">&gt;&gt;&gt;</span> tempo(132)   
<span class="int">&gt;&gt;&gt;</span> d = Thread(10)
<span class="int">&gt;&gt;&gt;</span> d.start()
</code></pre>
<p>There are additional functions for working with rhythms. For example, euclidean rhythms can be generated with the euc function</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> steps = 7
<span class="int">&gt;&gt;&gt;</span> pulses = 3
<span class="int">&gt;&gt;&gt;</span> note = K
<span class="int">&gt;&gt;&gt;</span> d.pattern = euc(steps, pulses, note)    # [K, 0, K, 0, K, 0, 0]
</code></pre>
<p>Adding a pattern to an existing pattern fills any 0s with the new pattern</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern.add(euc(7, 5, H))             # [K, H, K, H, K, 0, H]
</code></pre>
<p>XOR'ing a pattern to an existing pattern adds it, but turns any collisions into 0s</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern.xor([1, 1, 0, 0, 0, 0, 0])    # [0, 0, K, H, K, 0, H]
</code></pre>
<p>These can be done even if the patterns are different lengths, to create crossrhythms</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern = [K, K] * 2
<span class="int">&gt;&gt;&gt;</span> d.pattern.add([H, H, H, H, H])
</code></pre>
<p>Patterns can also be blended</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern = blend([K, K, K, K], [S, S, S, S])   # this is probabilistic and will be different every time!
</code></pre>
<p>same as</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern = K, K, K, K
<span class="int">&gt;&gt;&gt;</span> d.pattern.blend([S, S, S, S])
</code></pre>

</div>
</body>
</html>