<!doctype html> 
<html prefix="og: http://ogp.me/ns#" lang="en"> 
<head>
    <title>Braid MIDI sequencer</title> 
    <meta charset="utf-8"/>
    <meta name="robots" content="index,follow">
    <meta name="author" content="Brian House" /> 
    <meta name="copyright" content="Brian House" /> 
    <meta name="description" content="
Braid is a single-import module for Python 3 that comprises a musical notation system, livecoding framework, and sequencer for monophonic MIDI synths. Its emphasis is on polyrhythms, phasing, and entrainment." />
    <meta property="og:title" content="Braid" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="http://brianhouse.net/about/about.jpg" />
    <link rel="icon" href="/favicon.png" /> 
    <link rel="stylesheet" type="text/css" href="github-markdown.css" /> <!-- https://github.com/sindresorhus/github-markdown-css -->
    <style>
        body {
            margin: 0px;
            padding: 0px;       
            background: #87e0fd;
            background: linear-gradient(to bottom, #87e0fd 0%,#53cbf1 40%,#05abe0 100%);
        }
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 800px;
            margin: 0;
            margin-left: auto;
            margin-right: auto;
            margin-top: 50px;
            padding: 45px;
            background-color: white;
            border: 1px solid #ccc;
        }
        .int {
            color: #ccc;
        }
        .output {
            color: #ccc;
        }
    </style>    
</head>
<body>
<div id="content" class="markdown-body">

<h1>BRAID</h1>
<p>Braid is a single-import module for Python 3 that comprises a musical notation system, livecoding framework, and sequencer for monophonic MIDI synths. Its emphasis is on interpolation, polyrhythms, phasing, and entrainment.</p>
<ol>
<li><a href="#goals">Goals</a></li>
<li><a href="#reference">Reference</a></li>
<li><a href="#documentation">Documentation</a><ol>
<li><a href="#hello">Hello World</a></li>
<li><a href="#notes">Notes and <code>Thread.chord</code></a></li>
<li><a href="#pattern_1"><code>Thread.pattern</code>, part 1</a></li>
<li><a href="#pattern_2"><code>Thread.pattern</code>, part 2</a></li>
<li><a href="#velocity"><code>Thread.velocity</code> and <code>Thread.grace</code></a></li>
<li><a href="#phase"><code>Thread.phase</code></a></li>
<li><a href="#rate"><code>Thread.rate</code></a>    </li>
<li>functions in pattern / lambdas</li>
<li>tweens</li>
<li>signals</li>
<li>sync'ing</li>
<li>hardware: creating synthes for midi devices</li>
</ol>
</li>
</ol>
<h2>Goals</h2>
<ul>
<li>
<p><strong>Idiosyncratic</strong><br />
Braid is designed to embody the methods and aesthetics I've used in my projects. It does not intend to be for general purpose music making. It is an exercise in developing a domain-specific language for a very specific set of concerns, namely my interest evolving rhythmic relationships and data sonification.</p>
</li>
<li>
<p><strong>Limited scope</strong><br />
Braid is MIDI-based, it's monophonic, and it's only a sequencer, not a synthesizer. Those are pretty significant limitations, but it means that this exists and (mostly) works. It also means I can take advantage of all the awesome cheap MIDI monosynths coming out, like the <a href="https://meeblip.com/">Meeblip</a> and the <a href="http://i.korg.com/volcaseries">Korg Volca</a> series.</p>
</li>
<li>
<p><strong>Integrates with Python</strong><br />
I find specialized development environments frustrating, as they limit what's possible to their own sandbox. Braid is just a python module, and as such can be used within other python projects.  </p>
</li>
<li>
<p><strong>Both livecoding and scripting</strong><br />
 Sometimes I want to improvise within a livecoding framework, sometimes I want to make a composition. Braid doesn't make much of a distinction between these ways of operating, as it's all python and uses the interpreter as a livecoding environment. Premade scripts can be easily executed within the interpreter.</p>
</li>
<li>
<p><strong>Works on small devices</strong><br />
Braid is has very low processor overhead, suitable for running on devices like the Raspberry Pi.</p>
</li>
</ul>
<h4>A note on names</h4>
<p>This framework is called Braid, and the fundamental objects are called <em>threads</em>&mdash;a thread corresponds to a hardware or software monosynth, and refers to the temporal operations of Braid through which threads can come in and out of sync. This is not a thread in the programming sense (in that respect Braid is single-threaded).</p>
<h2><a name="reference"></a>Reference</h2>
<h3>Glossary</h3>
<ul>
<li>Thread</li>
<li>cycle</li>
</ul>
<h3>Global functions</h3>
<ul>
<li><code>log_midi(True|False)</code>        Choose whether to see MIDI output (default: False)</li>
<li><code>midi_out_interface(int)</code>     Change MIDI interface for output (zero-indexed)</li>
<li><code>Thread(int channel)</code>         Create a Thread on the specified MIDI channel</li>
<li><code>Scale([ints])</code>               Create a Scale with a list of ints corresponding to half-steps from root (0)</li>
<li><code>play()</code></li>
<li><code>pause()</code></li>
<li><code>stop()</code></li>
<li><code>clear()</code></li>
<li><code>tempo()</code></li>
</ul>
<h3>Symbols</h3>
<ul>
<li><code>K</code>, <code>S</code>, <code>H</code>, <code>O</code></li>
</ul>
<h3>Scales</h3>
<p><code>CHR</code> Chromatic<br />
<code>MAJ</code> Major<br />
<code>DOM</code> Dominant<br />
<code>MIN</code> Harmonic minor<br />
<code>PEN</code> Pentatonic<br />
<code>SUSb9</code> Suspended flat 9<br />
<code>ION</code> Ionian<br />
<code>DOR</code> Dorian<br />
<code>PRG</code> Phrygian<br />
<code>MYX</code> Myxolydian<br />
<code>AOL</code> Aolian<br />
<code>LOC</code> Locrian<br />
<code>MMI</code> ??<br />
<code>BLU</code> Blues<br />
<code>SDR</code> Gamelan Slendro<br />
<code>PLG</code> Gamelan Pelog<br />
<code>JAM</code> jamz  </p>
<h2><a name="documentation"></a>Documentation</h2>
<h3><a name="hello"></a>Hello World</h3>
<p>To begin working with Braid, download the repository and navigate to the root directory. Launch a python3 interpreter and import braid: </p>
<pre><code>$ python3
<span class="output">Python 3.6.0 (default, Mar  4 2017, 12:32:37) 
[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwin
Type "help", "copyright", "credits" or "license" for more information.</span>
<span class="int">&gt;&gt;&gt;</span> from braid import *
<span class="output">MIDI outputs available: ['to Max 1', 'to Max 2']
MIDI OUT: to Max 1
MIDI  IN: from Max 1
Loaded VolcaKick
Loaded VolcaBeats
Braid started
Playing</span>
</code></pre>
<p>Now, create a thread&mdash;the fundamental object of Braid&mdash;and start it:</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t = Thread(1)               # create a thread&amp;mdash;the argument indicates the MIDI channel
<span class="int">&gt;&gt;&gt;</span> t.pattern = C, C, C, C      # add a pattern
<span class="int">&gt;&gt;&gt;</span> t.start()                   # start it
</code></pre>
<p>That's it! You should be hearing the steady pulse of progress.</p>
<p>Alternately, you can create a python file with Braid syntax like this:</p>
<pre><code>#!/usr/bin/env python3

from braid import *
t = Thread(1)
t.pattern = C, C, C, C
t.start()

play()
</code></pre>
<p>Save it as <code>hello_world.py</code> and run <code>python3 hello_world.py 0</code>. The (optional) argument is the MIDI out interface to use.  </p>
<p>From now on, we'll assume that we're livecoding within the python3 interpreter, but the code works the same in a standalone file.  </p>
<h3><a name="top"></a>Top-level controls</h3>
<p>You can start and stop individual threads, with <code>some_thread.start()</code> and <code>some_thread.stop()</code>, which essentially behave like a mute button.  </p>
<p>Braid also has some universal playback controls. When Braid launches, it is automatically in play mode. Use <code>pause()</code> to mute everything, and <code>play()</code> to get it going again. If you use <code>stop()</code>, it will stop all threads, so you'll need to start them up again individually. <code>clear()</code> just stops the threads, but Braid itself is still going and if you start a thread it will sound right away.</p>
<p><em>Advanced note</em><br />
If you're doing a lot of livecoding, it's easy to create a new thread with the same name as an old one, and this can lead to orphan threads that you hear but can't reference. Use <code>stop()</code> or <code>clear()</code> to silence these.</p>
<p>Try it now:</p>
<pre><code>clear()
</code></pre>
<h3><a name="notes"></a>Notes and <code>chord</code></h3>
<p>Start a thread</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t = Thread(1)   # create a thread on channel 1
<span class="int">&gt;&gt;&gt;</span> t.start()
</code></pre>
<p>MIDI pitch value can be specified by MIDI number or with note-name aliases between C0 and B8. C is an alias for C4, likewise for the rest of the middle octave</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = C, C, C, C
</code></pre>
<p>is the same as  </p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 60, 60, 60, 60
</code></pre>
<p>0s simply sustain (no MIDI sent)  </p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = C, 0, C, C
</code></pre>
<p>Rests (explicit MIDI note-offs) are specified with a Z  </p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = C, Z, C, Z
</code></pre>
<p>By default, there is no specified chord. But if there is one, notes can be specified by scale degree</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.chord = C4, MAJ
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 3, 5, 7
</code></pre>
<p>Negative numbers designate the octave below  </p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = -5, -7, 1, 5
</code></pre>
<p>A chord consists of a root note and a scale. For example, <code>C, MAJ</code> is a major scale built off of C4. That means <code>1, 2, 3, 4, 5</code> is the equivalent of <code>C4, D4, E4, F4, G4</code>. But behind the scenes, it's specified like this: <code>Scale([0, 2, 4, 5, 7, 9, 11])</code>  </p>
<p>Built-in scales are:<br />
<code>CHR</code> Chromatic<br />
<code>MAJ</code> Major<br />
<code>DOM</code> Dominant<br />
<code>MIN</code> Harmonic minor<br />
<code>PEN</code> Pentatonic<br />
<code>SUSb9</code> Suspended flat 9<br />
<code>ION</code> Ionian<br />
<code>DOR</code> Dorian<br />
<code>PRG</code> Phrygian<br />
<code>MYX</code> Myxolydian<br />
<code>AOL</code> Aolian<br />
<code>LOC</code> Locrian<br />
<code>MMI</code> ??<br />
<code>BLU</code> Blues<br />
<code>SDR</code> Gamelan Slendro<br />
<code>PLG</code> Gamelan Pelog<br />
<code>JAM</code> jamz  </p>
<p>Custom scales can be generated with the following syntax, where numbers are chromatic steps from the root</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> whole_tone_scale = Scale([0, 2, 4, 6, 8, 10])
</code></pre>
<p>R specifies a random note in the scale</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.chord = C4, whole_tone_scale
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, R, R, -6
</code></pre>
<p>Grace notes are specified by using floats</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 1., 1., 1.
</code></pre>
<p>Use the g function to create a grace note on note specified with a symbol</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.chord = None
<span class="int">&gt;&gt;&gt;</span> t.pattern = C, g(C), g(C), g(C)
</code></pre>
<h3><a name="pattern_1"></a><code>pattern</code>, part 1</h3>
<p>Start a thread with a pattern</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> clear()
<span class="int">&gt;&gt;&gt;</span> t = Thread(1)
<span class="int">&gt;&gt;&gt;</span> t.start()
<span class="int">&gt;&gt;&gt;</span> t.chord = C, DOR
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 1, 1, 1
</code></pre>
<p>Once started, a thread repeats its pattern. Each repetition is called a <em>cycle</em>. Each cycle is subdivided evenly by the steps in the pattern.</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 0, 1, 0              # 4/4
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 0, 1                 # 3/4
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 1, 0, 1, 1, 0, 1     # 7/8
</code></pre>
<p>Each step of a pattern can be a note, but it can also be a subdivision</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 1, [1, 1], 1, 1
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, [1, 1], 1, [1, 1, 1]
</code></pre>
<p>...or a subdivision of subdivisions, ad finitum</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 1, [2, [1., 1.]], [3, [2, 1], 1.], [5, [4., 3.]]
</code></pre>
<p>So brackets indicate subdivisions. Parens, however, indicate a choice.</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.pattern = 1, (2, 3, 4), 1, 1
</code></pre>
<p>Brackets and parens can be combined to create intricate markov chains</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> clear()
<span class="int">&gt;&gt;&gt;</span> tempo(132)                  # set the universal tempo
<span class="int">&gt;&gt;&gt;</span> d = Thread(10)              # channel 10 is MIDI for drums
<span class="int">&gt;&gt;&gt;</span>
<span class="int">&gt;&gt;&gt;</span> d.pattern = [([K, H], [K, K]), (K, O)], (H, [H, K]), (S, [S, (O, K), 0, g(S)]), [[H, H], ([H, H], O, [g(S), g(S), g(S), g(S)])]         # K, S, H, O are built-in aliases for 36, 38, 42, 46
<span class="int">&gt;&gt;&gt;</span> d.start()
</code></pre>
<p>Patterns are python lists, so they can be manipulated as such</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern = [K, [O, H]] * 4
<span class="int">&gt;&gt;&gt;</span> d.pattern[2] = S
<span class="int">&gt;&gt;&gt;</span> d.pattern[6] = S
<span class="int">&gt;&gt;&gt;</span> d.pattern[6] = [(S, [S, K])]
</code></pre>
<h3><a name="pattern_2"></a><code>pattern</code>, part 2</h3>
<p>There are additional functions for working with rhythms. For example, euclidean rhythms can be generated with the euc function</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> clear()
<span class="int">&gt;&gt;&gt;</span> tempo(132)   
<span class="int">&gt;&gt;&gt;</span> d = Thread(10)
<span class="int">&gt;&gt;&gt;</span> d.start()
</code></pre>
<h3></h3>
<pre><code><span class="int">&gt;&gt;&gt;</span> steps = 7
<span class="int">&gt;&gt;&gt;</span> pulses = 3
<span class="int">&gt;&gt;&gt;</span> note = K
<span class="int">&gt;&gt;&gt;</span> d.pattern = euc(steps, pulses, note)    # [K, 0, K, 0, K, 0, 0]
</code></pre>
<p>Adding a pattern to an existing pattern fills any 0s with the new pattern</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern.add(euc(7, 5, H))             # [K, H, K, H, K, 0, H]
</code></pre>
<p>XOR'ing a pattern to an existing pattern adds it, but turns any collisions into 0s</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern.xor([1, 1, 0, 0, 0, 0, 0])    # [0, 0, K, H, K, 0, H]
</code></pre>
<p>These can be done even if the patterns are different lengths, to create crossrhythms</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern = [K, K] * 2
<span class="int">&gt;&gt;&gt;</span> d.pattern.add([H, H, H, H, H])
</code></pre>
<p>Patterns can also be blended</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern = blend([K, K, K, K], [S, S, S, S])   # this is probabilistic and will be different every time!
</code></pre>
<p>same as</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> d.pattern = K, K, K, K
<span class="int">&gt;&gt;&gt;</span> d.pattern.blend([S, S, S, S])
</code></pre>
<h3><a name="velocity"></a><code>Thread.velocity</code> and <code>Thread.grace</code></h3>
<p>All threads come with some properties built-in. We've seen <a href="#notes"><code>chord</code></a> already.  </p>
<pre><code><span class="int">&gt;&gt;&gt;</span> clear()
<span class="int">&gt;&gt;&gt;</span> t = Thread(10)
<span class="int">&gt;&gt;&gt;</span> t.start()
<span class="int">&gt;&gt;&gt;</span> t.chord = C, MAJ
<span class="int">&gt;&gt;&gt;</span> t.pattern = 1, 1., 1, 1.
</code></pre>
<p>There is also, of course, <code>velocity</code></p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.velocity = 0.5
</code></pre>
<p>and <code>grace</code> is a percentage of velocity, to control the depth of the grace notes</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t.velocity = 1.0
<span class="int">&gt;&gt;&gt;</span> t.grace = .45
</code></pre>
<h3><a name="phase"></a><code>Thread.phase</code></h3>
<p>Consider the following:</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> clear()    
<span class="int">&gt;&gt;&gt;</span>
<span class="int">&gt;&gt;&gt;</span> t1 = Thread(10)
<span class="int">&gt;&gt;&gt;</span> t1.chord = 76, CHR  # root note is "Hi Wood Block"
<span class="int">&gt;&gt;&gt;</span>
<span class="int">&gt;&gt;&gt;</span> t2 = Thread(10)
<span class="int">&gt;&gt;&gt;</span> t2.chord = 77, CHR  # root note is "Lo Wood Block"
<span class="int">&gt;&gt;&gt;</span>
<span class="int">&gt;&gt;&gt;</span> t1.pattern = [1, 1, 1, 0], [1, 1, 0, 1], [0, 1, 1, 0]   # thanks Steve
<span class="int">&gt;&gt;&gt;</span> t2.pattern = t1.pattern
<span class="int">&gt;&gt;&gt;</span>
<span class="int">&gt;&gt;&gt;</span> t1.start()
<span class="int">&gt;&gt;&gt;</span> t2.start(t1)            # t1 as argument
</code></pre>
<p>Note that in this example, <code>t2</code> takes <code>t1</code> as an argument. This ensures that t2 will start in sync with t1. Otherwise, t1 and t2 will start at arbitrary times, which may not be desirable.</p>
<p>However, each thread also has a <code>phase</code> property that allows us to control the relative phase of threads deliberately.</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> t2.phase = 1/12         # adjust phase by one subdivision
<span class="int">&gt;&gt;&gt;</span> t2.phase = 3/12
<span class="int">&gt;&gt;&gt;</span> t2.phase = 7/12
</code></pre>
<h3><a name="rate"></a><code>Thread.rate</code></h3>
<p>By default, the cycle of each thread corresponds to the universal tempo (as we've seen, the universal <code>tempo()</code> function sets the BPM, or at least the equivalent BPM if cycles were in 4/4 time).</p>
<p>However, individual threads can cycle at their own <code>rate</code>. If <code>1.0</code> is the universal rate at the specified tempo, the <code>rate</code> property of each thread is a multiplier.</p>
<pre><code><span class="int">&gt;&gt;&gt;</span> clear()
<span class="int">&gt;&gt;&gt;</span> t1 = Thread(1)
<span class="int">&gt;&gt;&gt;</span> t1.pattern = C, C, C, C
<span class="int">&gt;&gt;&gt;</span> t1.start()
<span class="int">&gt;&gt;&gt;</span>
<span class="int">&gt;&gt;&gt;</span> t2 = Thread(1)
<span class="int">&gt;&gt;&gt;</span> t2.pattern = G, G, G, G
<span class="int">&gt;&gt;&gt;</span> t2.rate = 0.5                   # half-speed! 
<span class="int">&gt;&gt;&gt;</span> t2.start(t1)
</code></pre>
<h3><a name="tweens"></a>Tweening</h3>
<p>Now for the fun part.</p>

</div>
</body>
</html>